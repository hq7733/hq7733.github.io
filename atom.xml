<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hq7733.github.io</id>
    <title>博客</title>
    <updated>2022-02-07T04:23:11.670Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hq7733.github.io"/>
    <link rel="self" href="https://hq7733.github.io/atom.xml"/>
    <logo>https://hq7733.github.io/images/avatar.png</logo>
    <icon>https://hq7733.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 博客</rights>
    <entry>
        <title type="html"><![CDATA[Sentinel]]></title>
        <id>https://hq7733.github.io/post/sentinel/</id>
        <link href="https://hq7733.github.io/post/sentinel/">
        </link>
        <updated>2022-02-07T04:10:27.000Z</updated>
        <content type="html"><![CDATA[<p>目录</p>
<h1 id="一-什么是-sentinel">一、什么是 Sentinel</h1>
<p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<h2 id="sentinel-的特征">Sentinel 的特征</h2>
<p>丰富的应用场景： Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷（对于突然到来的大量请求，您可以配置流控规则，以稳定的速度逐步处理这些请求，从而避免流量突刺造成系统负载过高）、集群流量控制、实时熔断下游不可用应用等<br>
完备的实时监控： Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况<br>
广泛的开源生态： Sentinel 提供开箱即用的与其它开源框架 / 库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel<br>
完善的 SPI 扩展点： Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等<br>
Sentinel 的组成<br>
核心库（Java 客户端）： 不依赖任何框架 / 库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持<br>
控制台（Dashboard）： 基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器</p>
<h1 id="二-sentinel入门">二、Sentinel入门</h1>
<h2 id="本地应用创建">本地应用创建</h2>
<p>整体流程分析</p>
<ol>
<li>创建SpringBoot项目</li>
<li>在pom.xml中引入sentinel-core依赖</li>
<li>创建TestController,定义使用限流规则</li>
<li>运行测试<br>
创建SpringBoot项目，命名为sentinel-quick-start</li>
</ol>
<p>在pom.xml中引入sentinel-core依赖<br>
<dependency><br>
<groupId>com.alibaba.csp</groupId><br>
<artifactId>sentinel-core</artifactId><br>
<version>1.8.0</version><br>
</dependency><br>
编写TestController<br>
@RestController<br>
public class TestController {</p>
<pre><code>    @GetMapping(&quot;/hello&quot;)
    public String hello(){
        try(Entry entry = SphU.entry(&quot;Hello&quot;)) {
            return &quot;Hello Sentinel&quot;;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return &quot;系统繁忙，请稍后&quot;;
    }

    /** 定义限流规则
    * @PostConstruct 此注解的含义是：本类构造方法执行结束后执行
    */
    @PostConstruct
    public void init(){
        //1.创建存放限流规则的集合
        List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;();
        //2.创建限流规则
        FlowRule rule = new FlowRule();
        //定义资源，表示Sentinel会对哪个资源生效
        rule.setResource(&quot;Hello&quot;);
        //定义限流的类型(此处使用QPS作为限流类型)
        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        //定义QPS每秒通过的请求数
        rule.setCount(2);
        //3.将限流规则存放到集合中
        rules.add(rule);
        //4.加载限流规则
        FlowRuleManager.loadRules(rules);
    }
}
</code></pre>
<p>运行测试</p>
<p>正常访问时</p>
<p>正常访问</p>
<p>当快速刷新，使QPS大于2时</p>
<p>繁忙图片</p>
<p>搭建Sentinel控制台<br>
首先下载Sentinel控制台<br>
https://github.com/alibaba/Sentinel/releases<br>
启动Sentinel</p>
<p>注意：启动 Sentinel 控制台需要 JDK 版本为 1.8 及以上版本</p>
<h1 id="在与jar包相同的文件夹下新建一个startbat">在与jar包相同的文件夹下新建一个start.bat</h1>
<p>java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8718 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar<br>
其中 -Dserver.port=8080 用于指定 Sentinel 控制台端口为 8718</p>
<p>注意： 从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的 登录 功能，默认用户名和密码都是 sentinel</p>
<p>本地应用接入控制台<br>
在本地应用的pom.xml文件中引入依赖</p>
<!-- Sentinel本地应用接入控制台 -->
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-transport-simple-http</artifactId>
    <version>1.8.0</version>
</dependency>
在本地应用添加JVM启动参数
<p>配置</p>
<p>-Dcsp.sentinel.dashboard.server=localhost:9000   Sentinel控制台的地址和端口号<br>
-Dproject.name=SentinelQuickStart				本地应用在控制台中的名称<br>
运行测试</p>
<p>第一次查看控制台需要先访问一次被限流控制的接口，否则控制台中没有东西</p>
<p>1602315326070</p>
<p>在控制台中设置限流规则<br>
Sentinel提供了两种设置流控规则的方式</p>
<p>在应用中使用代码编写流控规则（不推荐）<br>
在Sentinel控制台中设置流控规则</p>
<p>1602316065232</p>
<p>Sentinel定义资源的方式<br>
抛出异常的方式定义资源<br>
返回布尔值的方式定义资源<br>
异步调用支持<br>
注解方式定义资源<br>
主流框架的默认适配<br>
抛出异常的方式定义资源<br>
使用这种方式当资源发生限流后会抛出BlockException。这个时候可以捕获异常，进行限流之后的逻辑处理，关键代码如下：</p>
<pre><code>    try(Entry entry = SphU.entry(&quot;Hello&quot;)) {
        return &quot;Hello Sentinel&quot;;  //被保护的资源
    } catch (Exception e) {
        e.printStackTrace();
    }
    return &quot;系统繁忙，请稍后&quot;;
</code></pre>
<p>返回布尔值的方式定义资源<br>
使用的API为SphO，限流后返回的值为boolean类型<br>
注意：SphO.entry必须和SphO.exit成对出现 否则会报错</p>
<p>@GetMapping(&quot;/boolean&quot;)<br>
public boolean returnBoolean(){<br>
if (SphO.entry(&quot;Sentinel-boolean&quot;)){<br>
try {<br>
System.out.println(&quot;Hello Sentinel&quot;);<br>
return true;<br>
}finally {<br>
SphO.exit();//限流的出口<br>
}<br>
}else {<br>
//限流后进行的操作<br>
System.out.println(&quot;系统繁忙,请稍后再试&quot;);<br>
return false;<br>
}<br>
}</p>
<p>异步调用的支持<br>
在本地引导类中添加EnableAsync，表示SpringBoot项目开启异步调用支持<br>
@SpringBootApplication<br>
@EnableAsync<br>
public class SentinelQuickStartApplication {</p>
<pre><code>public static void main(String[] args) {
    SpringApplication.run(SentinelQuickStartApplication.class, args);
}
</code></pre>
<p>}<br>
创建AsyncService编写异步调用的方法<br>
@Service<br>
public class AsyncService {<br>
//Async表示方法为异步调用<br>
@Async<br>
public void hello(){<br>
System.out.println(&quot;异步调用开始======&quot;);<br>
try {<br>
Thread.sleep(5000);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
System.out.println(&quot;异步调用结束=====&quot;);<br>
}<br>
}<br>
编写Controller</p>
<p>@Autowired<br>
private AsyncService asyncService;</p>
<p>@GetMapping(&quot;/async&quot;)<br>
public void async(){<br>
//1.进行限流控制<br>
AsyncEntry asyncEntry = null;<br>
try {<br>
asyncEntry = SphU.asyncEntry(&quot;Sentinel_Async&quot;); //限流入口<br>
asyncService.hello(); //异步调用方法<br>
System.out.println(&quot;异步测试&quot;);<br>
} catch (BlockException e) {<br>
e.printStackTrace();<br>
System.out.println(&quot;系统繁忙请稍后再试&quot;);<br>
} finally {<br>
if (asyncEntry != null){<br>
asyncEntry.exit(); //限流出口<br>
}<br>
}<br>
}</p>
<p>注解方式定义资源<br>
Sentinel支持通过@SentinelResource定义资源并配置blockHandler函数来进行限流之后的处理。</p>
<p>在pom.xml中引入依赖</p>
<dependency>
	<groupId>com.alibaba.csp</groupId>
	<artifactId>sentinel-annotation-aspectj</artifactId>
	<version>1.8.0</version>
</dependency>
创建AspectJ的配置类
@Configuration
public class SentinelAspectConfiguration {
<pre><code>@Bean
public SentinelResourceAspect sentinelResourceAspect(){
    return new SentinelResourceAspect();
}
</code></pre>
<p>}<br>
创建Controller<br>
// value代表资源名称  blockHandler：设置限流或降级处理的类<br>
@SentinelResource(value = &quot;Sentinel_Ann&quot;,blockHandler = &quot;exceptionHandler&quot;)<br>
@GetMapping(&quot;/ann&quot;)<br>
public String ann(){<br>
//使用限流规则<br>
return &quot;Hello Sentinel&quot;;<br>
}</p>
<pre><code>public String exceptionHandler(BlockException e){
    e.printStackTrace();
    return &quot;系统繁忙请稍后再试&quot;;
}
</code></pre>
<p>三、Sentinel高级<br>
Spring Cloud 整合 Sentinel<br>
具体步骤</p>
<p>创建SpringBoot项目，在项目中引入spring-cloud-starter-alibaba-sentinel依赖<br>
<dependency><br>
<groupId>com.alibaba.cloud</groupId><br>
<artifactId>spring-cloud-starter-alibaba-sentinel</artifactId><br>
<version>2.2.3.RELEASE</version><br>
</dependency><br>
在项目中创建Test2Controller<br>
@RestController<br>
public class Test2Controller {</p>
<pre><code>@SentinelResource(value = &quot;sentinel_cloud&quot;,blockHandler = &quot;exceptionHandler&quot;)
@GetMapping(&quot;/sentinel_cloud&quot;)
public String ann(){
    //使用限流规则
    return &quot;Hello Sentinel&quot;;
}

public String exceptionHandler(BlockException e){
    e.printStackTrace();
    return &quot;系统繁忙请稍后再试&quot;;
}
</code></pre>
<p>}<br>
在application.yaml中加入以下配置</p>
<h1 id="设置应用的名称">设置应用的名称</h1>
<p>spring:<br>
application:<br>
name: springCloudSentinel<br>
cloud:<br>
sentinel:<br>
transport:<br>
dashboard: localhost:8718 #设置Sentinel控制台的主机地址和端口号<br>
测试</p>
<p>1602322826039</p>
<p>Sentinel整合Feign<br>
Sentinel适配了Feign组件。如果想要使用，除了引用spring-cloud-starter-alibaba-sentinel的依赖，还需要两个步骤：</p>
<p>配置打开Sentinel对Feign的支持：feign.sentinel.enable=true<br>
加入spring-cloud-starter-openfeign依赖使Sentinel starter自动化配置类生效<br>
这里配置中心使用的为Nacos，项目结构如下图所示</p>
<p>1602331509447</p>
<p>consumer模块中的类：<br>
Controller<br>
@RestController<br>
public class ConsumerController {</p>
<pre><code>@Resource
private ConsumerService consumerService;

@GetMapping(&quot;/sayHello&quot;)
public String getHello(){
    return consumerService.getHello();
}
</code></pre>
<p>}</p>
<p>Service<br>
@FeignClient(value = &quot;nacos-provider&quot;, fallback = ConsumerServiceImpl.class)<br>
public interface ConsumerService {</p>
<pre><code>@GetMapping(&quot;/sayHello&quot;)
String getHello();
</code></pre>
<p>}</p>
<p>@Service<br>
public class ConsumerServiceImpl implements ConsumerService {<br>
@Override<br>
public String getHello() {<br>
return &quot;break down&quot;;<br>
}<br>
}<br>
application.yaml</p>
<p>server:<br>
port: 9000</p>
<p>spring:<br>
application:<br>
name: nacos-consumer<br>
cloud:<br>
nacos:<br>
discovery:<br>
# 服务注册地址<br>
server-addr: 127.0.0.1:8848<br>
# 熔断限流<br>
sentinel:<br>
transport:<br>
# 控制台地址<br>
dashboard: localhost:8718<br>
#开启feign<br>
feign:<br>
sentinel:<br>
enabled: true</p>
<p>启动类：<br>
@SpringBootApplication<br>
//使用注册中心<br>
@EnableDiscoveryClient<br>
//获取注册中心的接口<br>
@EnableFeignClients<br>
public class NacosConsumerApplication {</p>
<pre><code>public static void main(String[] args) {
    SpringApplication.run(NacosConsumerApplication.class, args);
}
</code></pre>
<p>}<br>
provider模块中的类：<br>
@RestController<br>
public class ProviderController {</p>
<pre><code>@Autowired
private ConfigurableApplicationContext configurableApplicationContext;

@GetMapping(&quot;/sayHello&quot;)
public String sayHello(){
    return &quot;Hello provider &quot;;
}

@GetMapping(&quot;/sayHi&quot;)
public String sayHi(){
    String name = configurableApplicationContext.getEnvironment().getProperty(&quot;name&quot;);
    return &quot;Hi provider &quot; + name;
}
</code></pre>
<p>}<br>
application.yaml</p>
<p>server:<br>
port: 9002</p>
<p>spring:<br>
application:<br>
name: nacos-provider<br>
cloud:<br>
nacos:<br>
discovery:<br>
# 服务注册地址<br>
server-addr: 127.0.0.1:8848<br>
config:<br>
# 配置中心地址<br>
server-addr: 127.0.0.1:8848</p>
<p>启动类：<br>
@SpringBootApplication<br>
@EnableDiscoveryClient<br>
public class NacosProviderApplication {<br>
public static void main(String[] args) {<br>
SpringApplication.run(NacosProviderApplication.class, args);<br>
}<br>
}<br>
注意：如果发生错误<br>
NoSuchMethodErrorfeign.RequestTemplate.path（）Ljava / lang / String;<br>
我遇到的情况是因为版本不匹配造成的<br>
spring-cloud-starter-alibaba-sentinel 2.1.0.RELEASE，但其中的feign-core是9.5.0，这里面的RequestTemplate类却没有path方法，造成异常。</p>
<p>解决办法：</p>
<p>pom.xml</p>
<p>添加流量规则</p>
<p>1602332712021</p>
<p>注意此处的资源名格式为：<br>
http请求方式:协议://服务名/请求路径和参数</p>
<p>测试结果<br>
正常情况下：</p>
<p>1602332880600</p>
<p>QPS超过两次</p>
<p>1602332926361</p>
<p>Sentinel整合Spring Cloud gateway<br>
在gateway的pom.xml中引入依赖</p>
<dependency>
   <groupId>com.alibaba.cloud</groupId>
   <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
   <version>2.2.3.RELEASE</version>
</dependency>
<dependency>
   <groupId>com.alibaba.cloud</groupId>
   <artifactId>spring-cloud-alibaba-sentinel-gateway</artifactId>
   <version>2.2.3.RELEASE</version>
</dependency>
创建GatewayConfiguration配置类，配置流控降级回调操作
@Component
public class GatewayConfiguration {
     @PostConstruct
    public void doInit(){
         //设置限流或降级的回调函数
         GatewayCallbackManager.setBlockHandler(new BlockRequestHandler() {
             @Override
             public Mono<ServerResponse> handleRequest(ServerWebExchange serverWebExchange, java.lang.Throwable throwable) {
                return ServerResponse.status(200).syncBody("系统繁忙请稍后");
             }
         });
     }
}
在application.yaml中配置sentinel控制台访问地址
spring:
  cloud:
    sentinel:
      transport:
        port: 8718
        dashboard: 127.0.0.1:8080
启动项目，在Sentinel控制台中添加关于资源的控制规则，sentinel在适配spring cloud gateway时提供了两种配置规则
<p>route维度：即在spring配置文件配置的路由条数，资源名为对应的routeId<br>
自定义API维度：用户可以利用Sentinel提供的API来自定义一些自定义分组</p>
]]></content>
    </entry>
</feed>